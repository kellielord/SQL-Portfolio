-- In this project, I complete a sales analysis for the ClassicModels sample database. I create a table in MySQL Workbench that I further analyze in Excel.

-- #1. Provide a sales overview for the year 2004. Include a breakdown of product, country, and city, while also including the sales value, cost of sales, and net profit. 

SELECT 
    o.orderdate,
    od.orderNumber,
    od.quantityOrdered,
    od.priceeach,
    productName,
    productLine,
    productCode,
    buyPrice,
    c.city,
    c.country
FROM
    products p
        INNER JOIN
    orderdetails od ON od.productcode = p.productcode
        INNER JOIN
    orders o ON o.ordernumber = od.ordernumber
        INNER JOIN
    customers c ON c.customernumber = o.customernumber
WHERE
    YEAR(orderDate) = 2004
ORDER BY orderNumber ASC;


-- #2. Provide a breakdown of products that are commonly purchased together, and any products that are rarely purchased together.

WITH product_sales AS (
SELECT 
    ordernumber, 
    od.productcode, 
    p.productline
    
FROM
    orderdetails od
        
INNER JOIN products p 
	ON od.productcode = p.productcode
)

SELECT DISTINCT
    t1.ordernumber,
    t1.productline AS product_one,
    t2.productline AS product_two
FROM
    product_sales t1
        LEFT JOIN
    product_sales t2 ON t1.ordernumber = t2.ordernumber
        AND t1.productline <> t2.productline;

-- #3. Break down sales data by grouping customer credit limits into ranges. Maybe look for a pattern where higher credit limits are linked to higher sales. 

WITH sales AS
(
SELECT 
    o.ordernumber,
    c.customernumber,
    od.productcode,
    od.quantityOrdered,
    od.priceeach,
    priceeach * quantityordered AS salesvalue,
    creditlimit
FROM
    customers c
        INNER JOIN
    orders o ON o.customernumber = c.customernumber
        INNER JOIN
    orderdetails od ON od.ordernumber = o.ordernumber
    )

SELECT 
    ordernumber,
    customernumber,
    CASE
        WHEN creditlimit < 75000 THEN 'a: Less than $75k'
        WHEN creditlimit BETWEEN 75000 AND 100000 THEN 'b: $75k to 100k'
        WHEN creditlimit BETWEEN 100000 AND 150000 THEN 'c: $100k to 150k'
        WHEN creditlimit > 150000 THEN 'd: Over $150k'
        ELSE 'Other'
    END AS creditlimit_group,
    SUM(salesvalue) AS salesvalue
FROM
    sales
GROUP BY ordernumber , customernumber , creditlimit_group;

-- #4. Create a view demonstrating customer sales and include a column which shows the difference in value from their previous sale. Determine whether new customers making their first purchase are likely to spend more. 

WITH main_cte AS ( 
SELECT 
    ordernumber,
    orderdate,
    customernumber,
    SUM(salesvalue) AS salesvalue
FROM (
	SELECT 
        o.ordernumber,
            orderdate,
            c.customernumber,
            quantityOrdered * priceeach AS salesvalue
    FROM
        orders o
    INNER JOIN orderdetails od ON od.ordernumber = o.ordernumber
    INNER JOIN customers c ON c.customerNumber = o.customerNumber
    ) main
GROUP BY ordernumber, orderdate, c.customernumber 
),

sales_query AS (
SELECT 
	t1.*, 
    customername, 
    ROW_NUMBER() OVER (PARTITION BY customername ORDER BY orderdate) AS purchasenumber,
	LAG(salesvalue) OVER (PARTITION BY customername ORDER BY orderdate) AS prevsalesvalue
FROM main_cte t1
	INNER JOIN customers t2 ON t1.customernumber = t2.customernumber 
)

SELECT 
    *, salesvalue - prevsalesvalue AS purchase_value_change
FROM
    sales_query
WHERE
    prevsalesvalue IS NOT NULL

-- #5. Provide a view of where the customers of each office are located. 

WITH main_cte AS (
SELECT 
    c.customerNumber, 
    customerName, 
    c.city AS customerCity,
    c.country AS customerCountry,
    c.state AS customerState,
    e.officeCode,
    o1.orderNumber,
    od.quantityOrdered * od.priceEach AS salesValue,
    p.productCode,
    p.productLine,
    o.city AS officeCity,
    o.state AS officeState,
    o.country AS officeCountry
FROM
    customers c
INNER JOIN employees e 
	ON e.employeeNumber = c.salesRepEmployeeNumber
INNER JOIN offices o
	ON o.officeCode = e.officeCode
INNER JOIN orders o1
	ON o1.customerNumber = c.customerNumber
INNER JOIN orderdetails od
	ON od.orderNumber = o1.orderNumber
INNER JOIN products p
	ON p.productCode = od.productCode
)

SELECT
	ordernumber,
    customercity,
    customercountry, 
    productLine, 
    officeCity,
    officeCountry, 
    sum(salesValue) as salesValue
FROM main_cte
GROUP BY
	orderNumber,
	customercity,
    customercountry,
    productline,
    officecity,
    officecountry
    

-- #6. Due to weather, some shipments could take up to 3 days to arrive. Provide a list of affected orders.

SELECT 
    *,
    DATE_ADD(shippedDate, INTERVAL 3 DAY) AS latestArrival,
    CASE
        WHEN DATE_ADD(shippedDate, INTERVAL 3 DAY) > requiredDate THEN 1
        ELSE 0
    END AS lateFlag
FROM
    orders
WHERE
    (CASE
        WHEN DATE_ADD(shippedDate, INTERVAL 3 DAY) > requiredDate THEN 1
        ELSE 0
    END) = 1

-- #7. Provide a breakdown of each customer and their sales, but include a "money owed column" to include any clients that have exceeded their credit limit.

WITH cte_sales AS (
SELECT 
    orderDate,
    od.orderNumber,
    c.customerNumber,
    customerName,
    productCode,
    creditLimit,
    quantityOrdered * priceEach AS salesValue
FROM orders o
        INNER JOIN
    orderDetails od ON od.orderNumber = o.orderNumber
        INNER JOIN
    customers c ON o.customerNumber = c.customerNumber
),

runningTotalSales AS (
SELECT *, LEAD(orderDate) OVER (PARTITION BY customerNumber ORDER BY orderDate) AS nextOrderDate
FROM
	(
	SELECT 
		orderDate,
		orderNumber,
		customerNumber,
		customerName,
		creditLimit,
		SUM(salesValue) AS salesValue
	 FROM cte_sales
	 GROUP BY 
		orderDate,
		orderNumber,
		customerNumber,
		customerName,
		creditLimit
	) subquery 
) ,

cte_payments AS (
SELECT *
 FROM payments
 ),
 
 main_cte AS (
SELECT t1.*,
	SUM(salesValue) OVER (PARTITION BY t1.customerNumber ORDER BY orderDate) AS runningTotalSales,
	SUM(amount) OVER (PARTITION BY t1.customerNumber ORDER BY orderDate) AS runningTotalPayments
FROM runningTotalSales t1
LEFT JOIN cte_payments t2
	ON t1.customerNumber = t2.customerNumber AND t2.paymentDate BETWEEN t1.orderDate AND CASE WHEN  t1.nextOrderDate IS NULL THEN current_date() ELSE nextOrderDate END 
)

SELECT *, runningTotalSales - runningTotalPayments AS moneyOwed,
creditLimit - (runningTotalSales - runningTotalPayments) AS difference
FROM main_cte



    
